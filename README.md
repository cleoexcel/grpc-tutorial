1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?

- Pada Unary RPC: Client hanya mengirimkan data ke server sekali dan menerima responsnya. Hal ini dapat digunakan pada situasi dimana client hanya perlu mengirim data ke server dan menunggu respons, seperti autentikasi/autorisasi dan pengiriman form.
- Pada Server Streaming RPC: Server streaming memiliki perbedaan yaitu saat server mengirimkan informasi banyak sekaligus melalui 1 grpc stream. Hal ini berguna ketika server perlu mengirimkan data dalam jumlah yang sangat banyak berkali-kali sehingga tidak perlu dibuatnya koneksi baru karena overheadnya lebih mahal. Yang dilakukan adalah server akan mengirimkan data berulang kali melalui 1 koneksi yang sama sehingga data yang terkirimkan adalah potongan data-data yang membentuk data yang lebih besar. Misal pada harga saham, berita atau dataset yang besar dikirimkan dalam potongan-potongan.
- Bi-Directional Streaming RPC: Baik client maupun server terlibat dalam pengiriman data melalui stream yang sama.  Hal ini dapat digunakan pada situasi di mana client dan server perlu saling berkomunikasi secara real-time dan interaktif, seperti kolaborasi editing, permainan real-time, atau chatbot.


2.  What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?

- gRPC membutuhkan validasi autorisasi/autentikasi pada setiap potongan data yang dikirim, berbeda dengan REST yang memerlukan validasi hanya sekali per permintaan. Setiap potongan data dalam gRPC juga perlu dienkripsi secara terpisah, meningkatkan proses keamanan. Jadi, gRPC menuntut proses autorisasi/autentikasi/enkripsi yang berulang dalam satu permintaan, berbeda dengan REST yang hanya memerlukan validasi sekali. Dalam autorisasi/autentikasi untuk tiap potongan data yang dikirimkan oleh grpc diperlukannya validasi autorisasi/autentikasi untuk menjamin keamanannya dimana ini tidak sama seperti REST karena pada REST hanya diperlukannya 1 kali validasi untuk tiap request. Untuk enkripsi data, tiap potongan data yang dikirimkan baik oleh server maupun client perlu di enkripsi secara terpisah untuk menjamin privasi dari data yang dikirim.

3.  What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?

- Dalam pengembangan aplikasi chat menggunakan Rust dan gRPC dengan bidirectional streaming, sejumlah tantangan teknis dapat muncul. Salah satunya adalah menjaga sinkronisasi pesan antara klien dan server agar komunikasi berjalan konsisten tanpa kehilangan data. Selain itu, ada risiko terjadinya race condition dan deadlock, khususnya ketika kedua pihak saling menunggu pengiriman data. Jika pesan tidak segera dikonsumsi, buffer dapat mengalami overflow yang berdampak pada performa sistem. Karena koneksi streaming bersifat jangka panjang, ini juga menyulitkan proses load balancing, sebab koneksi yang terus aktif sulit untuk dialihkan atau dihentikan tanpa mengganggu komunikasi. Oleh karena itu, diperlukan strategi manajemen koneksi yang efisien, mekanisme pemulihan kesalahan, serta jaminan keamanan seperti enkripsi dan autentikasi pada setiap sesi komunikasi.

4. What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
- Penggunaan tokio_stream::wrappers::ReceiverStream dalam layanan streaming gRPC berbasis Rust memberikan sejumlah keunggulan, terutama dalam hal fleksibilitas dan integrasi. Pendekatan ini memungkinkan layanan gRPC untuk mengkonsumsi data secara asinkron dari berbagai sumber seperti channel atau future, dan sangat cocok dipadukan dengan komponen lain dalam ekosistem Tokio. Namun, di balik fleksibilitas tersebut, terdapat tantangan berupa kompleksitas tambahan dalam pengelolaan alur asynchronous, khususnya bagi pengembang yang belum terbiasa dengan model pemrograman non-blocking. Dalam konteks bi-directional streaming, penggunaan ReceiverStream juga harus diimbangi dengan perhatian khusus terhadap masalah concurrency, seperti potensi race condition dan kebutuhan sinkronisasi antara thread. Selain itu, karena gRPC mendukung koneksi jangka panjang, beban pada server dapat meningkat terutama jika banyak koneksi tidak dikelola dengan benar, sehingga menyulitkan load balancing dan pengaturan sumber daya dengan efisien.

5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?
- Untuk memfasilitasi code reuse, modularitas, dan kemudahan pemeliharaan jangka panjang, kode Rust gRPC sebaiknya disusun dengan pendekatan arsitektur yang terpisah dengan jelas antara antarmuka, logika bisnis, dan implementasi transport. File .proto berfungsi sebagai kontrak formal antar layanan yang menghasilkan interface secara otomatis melalui code generation. Interface ini dapat diimplementasikan sebagai service trait di Rust, memungkinkan pengembang memisahkan logika implementasi dari definisi layanan. Pendekatan ini tidak hanya memudahkan penambahan atau modifikasi fitur tanpa mempengaruhi komponen lain, tetapi juga memungkinkan pengujian unit yang lebih terfokus. Modularisasi dengan membagi kode ke dalam crate atau modul seperti service, handler, model, dan utils akan meningkatkan keterbacaan, reusabilitas, dan skalabilitas proyek seiring bertambahnya kompleksitas sistem.

6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?
- Dalam mengembangkan MyPaymentService untuk menangani logika pembayaran yang lebih kompleks, sejumlah langkah tambahan perlu dipertimbangkan. Ini mencakup validasi input secara menyeluruh, mekanisme penanganan error yang robust (misalnya untuk transaksi gagal atau timeout), serta penerapan autentikasi dan otorisasi yang aman untuk memastikan bahwa hanya pengguna yang sah dapat melakukan transaksi. Selain itu, integrasi dengan sistem eksternal seperti payment gateway, pengelolaan status transaksi (pending, berhasil, gagal), serta penyimpanan log transaksi secara aman sangat penting untuk menjaga konsistensi dan auditabilitas. Untuk skenario yang memerlukan interaksi berkelanjutan, seperti pemrosesan batch atau transaksi bertahap, pendekatan server streaming bisa menjadi pilihan yang lebih efisien dibanding unary. Dengan streaming, data status atau respons dapat dikirimkan secara bertahap dalam satu koneksi yang terbuka, mengurangi overhead koneksi berulang dan memberikan feedback real-time kepada pengguna.

7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?
- Penggunaan gRPC sebagai protokol komunikasi membawa dampak terhadap arsitektur sistem terdistribusi, terutama dalam hal interoperabilitas lintas teknologi dan platform. Dengan adanya definisi layanan yang terstandarisasi melalui file .proto, gRPC secara otomatis menghasilkan kode klien dan server yang dapat saling memahami struktur data dan pemanggilan metode tanpa bergantung pada HTTP verb atau format konvensional seperti REST. Hal ini menyederhanakan proses integrasi antarkomponen, memungkinkan klien untuk memanggil fungsi pada server layaknya memanggil prosedur lokal. Arsitektur menjadi lebih konsisten dan efisien karena komunikasi berlangsung melalui kontrak eksplisit yang mendukung berbagai bahasa pemrograman dan lingkungan eksekusi, sehingga memudahkan kolaborasi antar tim dan perluasan sistem secara modular.an mudah memanggil fungsi dari server, menyederhanakan konektivitas dan operasi antar berbagai teknologi, platform, dan sistem yang terdistribusi.

8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
- HTTP/2, sebagai protokol dasar gRPC, menawarkan sejumlah keunggulan dibandingkan HTTP/1.1 dan HTTP/1.1 dengan WebSocket, terutama dalam hal efisiensi koneksi. Fitur seperti multiplexing memungkinkan banyak permintaan dan respons dikirim melalui satu koneksi yang tetap terbuka, tanpa perlu membuat koneksi baru untuk setiap transaksi. Selain itu, kompresi header dan dukungan server push dapat secara signifikan meningkatkan performa pada skenario dengan beban data besar. Namun, keunggulan tersebut datang dengan konsekuensi berupa peningkatan kompleksitas dan konsumsi sumber daya, terutama dalam hal penggunaan memori dan manajemen koneksi. Untuk payload yang kecil atau aplikasi dengan transaksi ringan, HTTP/1.1 bisa jadi lebih hemat dan cukup efisien. Dengan demikian, HTTP/2 sangat ideal untuk sistem dengan kebutuhan komunikasi intensif dan real-time, tetapi mungkin berlebihan untuk aplikasi sederhana 

9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?
- REST API menggunakan model komunikasi berbasis permintaan dan tanggapan satu arah, di mana server hanya merespons jika ada permintaan eksplisit dari klien. Setiap interaksi umumnya memerlukan pembukaan dan penutupan koneksi baru, sehingga tidak optimal untuk komunikasi real-time. Sebaliknya, gRPC dengan dukungan bidirectional streaming memungkinkan klien dan server untuk saling bertukar data secara langsung dalam satu koneksi yang persistif. Karena koneksi tetap terbuka sepanjang sesi, gRPC dapat mengirimkan pembaruan secara instan tanpa perlu menunggu permintaan tambahan dari klien. Ini membuat gRPC jauh lebih responsif dan efisien dalam skenario real-time seperti live chat, notifikasi langsung, atau kolaborasi online, di mana latensi rendah dan komunikasi dua arah sangat krusial.

10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?
- Pendekatan berbasis skema pada gRPC yang menggunakan Protocol Buffers memberikan sejumlah keuntungan dibandingkan pendekatan schema-less seperti JSON pada REST API. Dengan Protobuf, struktur data didefinisikan secara eksplisit melalui file .proto, yang kemudian digunakan untuk menghasilkan kode otomatis di sisi klien dan server. Hal ini memastikan bahwa data yang dikirim dan diterima sesuai dengan kontrak yang telah disepakati, sehingga mengurangi risiko kesalahan seperti tipe data yang tidak cocok atau field yang hilang. Sebaliknya, JSON menawarkan fleksibilitas yang tinggi, namun justru karena tidak memiliki skema baku, validasi struktur data menjadi tanggung jawab penuh aplikasi, meningkatkan kemungkinan terjadinya kesalahan saat parsing atau pemrosesan data. Meskipun Protobuf memerlukan tahap belajar dan konfigurasi awal yang lebih kompleks, pendekatan ini memberikan efisiensi dalam serialisasi, ukuran payload yang lebih kecil, dan keandalan yang tinggi dalam komunikasi antar layanan, menjadikannya pilihan ideal untuk sistem terdistribusi berskala besar.